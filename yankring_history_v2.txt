else {        std::cout << z_buffer[z_buff_idx] << "," << pix_z << "\n";      }  ,v
, perspective_proj,v
z_buffer[z_buff_idx],v
        ,V
,,v
 t,v
 l,v
float ,v
 ,v
float,v
Vec2f ,v
 *                       pix_z,v
template <class t> Vec2<t> operator/(const Vec2<t> &v, float f) {  return Vec2<t>(v.x / f, v.y / f);},v
template <class t> friend Vec3<t> operator/(const Vec3<t> &v, float f); ,v
,V
template <class t> Vec3<t> operator/(float f, const Vec3<t> &v) {  return Vec3<t>(v.x / f, v.y / f);},v
  template <class t> friend Vec3<t> operator/(float f, const Vec3<t> &v);,V
template <class t> friend Vec3<t> operator*(float f, const Vec3<t> &v);  template <class t> friend Vec3<t> operator*(const Vec3<t> &v, float f); ,v
template <class t> Vec2<t> operator*(float f, const Vec2<t> &v) {  return Vec2<t>(v.x * f, v.y * f);}template <class t> Vec2<t> operator*(const Vec2<t> &v, float f) {  return Vec2<t>(v.x * f, v.y * f);}template <class t> Vec3<t> operator*(float f, const Vec3<t> &v) {  return Vec3<t>(v.x * f, v.y * f);}template <class t> Vec3<t> operator*(const Vec3<t> &v, float f) {  return Vec3<t>(v.x * f, v.y * f);},v
, c,v
float f,v
template <class t> friend Vec3<t> operator*(float f, const Vec3<t> &v); ,v
template <class t> Vec2<t> operator*(float f, const Vec2<t> &v) {  return Vec2<t>(v.x * f, v.y * f);}template <class t> Vec2<t> operator*(const Vec2<t> &v, float f) {  return Vec2<t>(v.x * f, v.y * f);},v
template <class t> Vec2<t> operator*(float f, Vec2<t> &v){  return Vec2<t>(v.x*f, v.y*f);},v
inline Vec3<t> operator*(float f) const {    return Vec3<t>(x * f, y * f, z * f);  },v
inline Vec2<t> operator*(float f) const { return Vec2<t>(u * f, v * f); } ,v
Vec2f pix_uv = verts_uv[0] * bary_P[0] + verts_uv[1] * bary_P[1] +                     verts_uv[2] * bary_P[2]; ,v
float pix_z = bary_P[0] * verts_[0].z + bary_P[1] * verts_[1].z +                    bary_P[2] * verts_[2].z; ,v
= false,v
void rasterizeObjwithTexture(const char *filename, const char *textfile,                             TGAImage &Image, Vec3f light_dir),v
v0_p.x =  v0_p.x/(1. - (v0_p.z/c)); ,v
imgvid_res256_DeterUnifNoise_INtrsFalse_Projdebug,v
0,v
SSIAnim: Extract pose for the FDS datasetScheduled: Apr 28, 2020 at 4:00 PM to 5:00 PM,V
light_intensity,v
      std::cout << pix_c_idx << "\n";,V
      std::cout << pix_uv << "\n";,V
      ,V
std::cout<<"$$$$$$$$$$$$$$$$\n"; ,v
std::cout<<verts_uv[0]<<"\n"; ,v
  TextureImg.flip_vertically();,V
      Vec2f uv = ;,V
Vec2f(uv[0], uv[1]),v
      std::cout << v << "\n";,V
      std::cout << l_trash << "\n";,V
      std::cout << uv << "\n";,V
    ,V
rasterizeObjwithTexture(const char *filename, const char *textfile,                             TGAImage &Image, Vec3f light_dir),v
             \+ 198   | }+ 131,v
./obj/african_head/african_head.obj,v
rasterizeObj("./obj/african_head/african_head.obj", image, light_dir);,v
const ,v
(float),v
i_vt,,v
rasterize_texture(float *z_buffer, TGAImage &Image,                                 const Vec2f *verts_uv, TGAImage &TextureImg,                                 float light_intensity),v
texture,v
int text_width = texture.get_width();  int text_height = texture.get_height(); ,v
void Triangle::rasterize(float *z_buffer, TGAImage &Image,                         const TGAColor &Color) {  // Doesnt use perspective correction  Vec2i img_bbox(Image.get_width() - 1, Image.get_height() - 1);  int img_width = Image.get_width();  Vec2i *tri_bbox = getBoundingBox();  tri_bbox[1].x = std::min(img_bbox.x, tri_bbox[1].x);  tri_bbox[1].y = std::min(img_bbox.y, tri_bbox[1].y);  Vec2i P;  for (P.x = tri_bbox[0].x; P.x < tri_bbox[1].x; P.x++) {    for (P.y = tri_bbox[0].y; P.y < tri_bbox[1].y; P.y++) {      if (P.x < 0 || P.x > img_bbox.x)        continue;      if (P.y < 0 || P.y > img_bbox.y)        continue;      Vec3f bary_P = barycoords(P);      if (bary_P.x < 0 || bary_P.y < 0 || bary_P.z < 0)        continue;      float pix_z = bary_P[0] * verts_[0].z + bary_P[1] * verts_[1].z +                    bary_P[2] * verts_[2].z;      int z_buff_idx = P.x + P.y * img_width;      if (z_buffer[z_buff_idx] < pix_z) {        z_buffer[z_buff_idx] = pix_z;        Image.set(P.x, P.y, Color);      }    }  }},v
int x0 = (v0.x + 1.) * width / 2;  // World -> Screen      int y0 = (v0.y + 1.) * height / 2; // World -> Screen      float z0 = v0.z;      tri_verts_screen[j] = Vec3f((float)x0, (float)y0, z0);      tri_verts_world[j] = v0; ,v
std::vector<int> face = model->face(i);,v
for (int j = 0; j < 3; j++) {      Vec3f v0 = model->vert(face[j]);      int x0 = (v0.x + 1.) * width / 2;  // World -> Screen      int y0 = (v0.y + 1.) * height / 2; // World -> Screen      float z0 = v0.z;      tri_verts_screen[j] = Vec3f((float)x0, (float)y0, z0);      tri_verts_world[j] = v0;    },v
std::vector<int> Model::face(int idx) { return faces_[idx]; } ,v
std::vector<int> face(int idx);,v
Vec3f Model::vert(int i) { return verts_[i]; } ,v
void rasterizeObj(const char *filename, TGAImage &Image, Vec3f light_dir) {  Model *model = NULL;  model = new Model(filename);  int width = Image.get_width();  int height = Image.get_height();  float *z_buffer = new float[height * width];  for (int i = width * height; i--;       z_buffer[i] = -std::numeric_limits<float>::max())    ;  for (int i = 0; i < model->nfaces(); i++) {    std::vector<int> face = model->face(i);    Vec3f tri_verts_screen[3];    Vec3f tri_verts_world[3];    for (int j = 0; j < 3; j++) {      Vec3f v0 = model->vert(face[j]);      int x0 = (v0.x + 1.) * width / 2;  // World -> Screen      int y0 = (v0.y + 1.) * height / 2; // World -> Screen      float z0 = v0.z;      tri_verts_screen[j] = Vec3f((float)x0, (float)y0, z0);      tri_verts_world[j] = v0;    }    Vec3f face_normal = (tri_verts_world[2] - tri_verts_world[0]) ^                        (tri_verts_world[1] - tri_verts_world[0]);    face_normal.normalize();    float light_intensity = face_normal * light_dir;    if (light_intensity < 0) {      light_intensity = 0;    }    TGAColor face_color(light_intensity * 255, light_intensity * 255,                        light_intensity * 255, 255);    Triangle face_tri(tri_verts_screen[0], tri_verts_screen[1],                      tri_verts_screen[2]);    face_tri.rasterize(z_buffer, Image, face_color);  }  delete model;},v
std::vector<Vec3f> verts_;,v
if (!line.compare(0, 2, "v ")) {      iss >> trash;      Vec3f v;      for (int i = 0; i < 3; i++)        iss >> v.raw[i];      verts_.push_back(v);    },v
},v
-,v
1,v
drawObjShade("./obj/african_head/african_head.obj", image, light_dir);,v
void rasterzieObj(const char *filename, TGAImage &Image, Vec3f light_dir),v
void drawObjShade(const char *filename, TGAImage &Image, Vec3f light_dir) {  Model *model = NULL;  model = new Model(filename);  int width = Image.get_width();  int height = Image.get_height();  for (int i = 0; i < model->nfaces(); i++) {    std::vector<int> face = model->face(i);    Vec3f tri_verts_screen[3];    Vec3f tri_verts_world[3];    for (int j = 0; j < 3; j++) {      Vec3f v0 = model->vert(face[j]);      int x0 = (v0.x + 1.) * width / 2;  // World -> Screen      int y0 = (v0.y + 1.) * height / 2; // World -> Screen      float z0 = v0.z;      tri_verts_screen[j] = Vec3f((float)x0, (float)y0, z0);      tri_verts_world[j] = v0;    }    Vec3f face_normal = (tri_verts_world[2] - tri_verts_world[0]) ^                        (tri_verts_world[1] - tri_verts_world[0]);    face_normal.normalize();    float light_intensity = face_normal * light_dir;    if (light_intensity > 0) {      TGAColor face_color(light_intensity * 255, light_intensity * 255,                          light_intensity * 255, 255);      Triangle face_tri(tri_verts_screen[0], tri_verts_screen[1],                        tri_verts_screen[2]);      face_tri.drawFill(Image, face_color);    }  }  delete model;},v
      std::cout << face_normal.z << "\n";,V
inline t operator[](int index) const {    if (index == 0) {      return x    } else if (index == 1) {      return y    } else if (index == 2) {      return z    } else {      throw std::out_of_range("Vec3 has length 3!")    }  },v
void Triangle::rasterize(float *z_buffer, TGAImage &Image,                         const TGAColor &Color),v
Image.set(P.x, P.y, Color);,v
sc_verts[0] = Vec2i(t1_.x, t1_.y); ,v
sc_verts[0] = Vec2i(t0_.x, t0_.y); ,v
void Triangle::drawFill(TGAImage &Image, const TGAColor &Color) {  Vec2i img_bbox(Image.get_width() - 1, Image.get_height() - 1);  Vec2i *tri_bbox = getBoundingBox();  tri_bbox[1].x = std::min(img_bbox.x, tri_bbox[1].x);  tri_bbox[1].y = std::min(img_bbox.y, tri_bbox[1].y);  Vec2i P;  for (P.x = tri_bbox[0].x; P.x < tri_bbox[1].x; P.x++) {    for (P.y = tri_bbox[0].y; P.y < tri_bbox[1].y; P.y++) {      if (P.x < 0 || P.x > img_bbox.x)        continue;      if (P.y < 0 || P.y > img_bbox.y)        continue;      Vec3f bary_P = barycoords(P);      if (bary_P.x < 0 || bary_P.y < 0 || bary_P.z < 0)        continue;      Image.set(P.x, P.y, Color);    }  }},v
    # upload_process = pexpect.s,V
Jess Glynne,v
clown_colors,v
drawObjClown("./obj/african_head/african_head.obj", image); ,v
void drawObjShade(const char *filename, TGAImage &Image, Vec3f light_dir),v
i,v
Clown,v
void drawObjClown(const char *filename, TGAImage &Image) {  Model *model = NULL;  model = new Model(filename);  int width = Image.get_width();  int height = Image.get_height();  for (int i = 0; i < model->nfaces(); i++) {    std::vector<int> face = model->face(i);    Vec2i tri_verts[3];    for (int j = 0; j < 3; j++) {      Vec3f v0 = model->vert(face[j]);      int x0 = (v0.x + 1.) * width / 2;  // World -> Screen      int y0 = (v0.y + 1.) * height / 2; // World -> Screen      tri_verts[j] = Vec2i(x0, y0);    }    TGAColor rand_color(arc4random() % 255, arc4random() % 255,                        arc4random() % 255, 255);    Triangle face_tri(tri_verts[0], tri_verts[1], tri_verts[2]);    face_tri.drawFill(Image, rand_color);  }  delete model;},v
output_mod,v
void drawObjClown(const char *filename, TGAImage &Image) ,v
drawObjWire("./obj/african_head/african_head.obj", image,v
Vec2i t0[3] = {Vec2i(10, 70), Vec2i(50, 160), Vec2i(70, 80)};  Vec2i t1[3] = {Vec2i(180, 50), Vec2i(150, 1), Vec2i(70, 180)};  Vec2i t2[3] = {Vec2i(180, 150), Vec2i(120, 160), Vec2i(130, 180)};  Triangle tri1 = Triangle(t0[0], t0[1], t0[2]);  Triangle tri2 = Triangle(t1[0], t1[1], t1[2]);  Triangle tri3 = Triangle(t2[0], t2[1], t2[2]);  tri1.drawFill(image, red);  tri2.drawFill(image, white);  tri3.drawFill(image, green); ,v
),v
TGAColor(rand()%255, rand()%255, rand()%255, 255)),v
      Vec3f v1 = model->vert(face[(j + 1) % 3]);,V
Vec3f v1 = model->vert(face[(j + 1) % 3]);      int x0 = (v0.x + 1.) * width / 2;      int y0 = (v0.y + 1.) * height / 2;      int x1 = (v1.x + 1.) * width / 2;      int y1 = (v1.y + 1.) * height / 2;      Vec2i t0;      Vec2i t1;      t0.x = x0;      t0.y = y0;      t1.x = x1;      t1.y = y1;      line(t0, t1, Image, Color); ,v
int main(int argc, char **argv) {  TGAImage image(width, height, TGAImage::RGB);  // drawObjWire("./obj/african_head/african_head.obj", image, red);  Vec2i t0[3] = {Vec2i(10, 70), Vec2i(50, 160), Vec2i(70, 80)};  Vec2i t1[3] = {Vec2i(180, 50), Vec2i(150, 1), Vec2i(70, 180)};  Vec2i t2[3] = {Vec2i(180, 150), Vec2i(120, 160), Vec2i(130, 180)};  Triangle tri1 = Triangle(t0[0], t0[1], t0[2]);  Triangle tri2 = Triangle(t1[0], t1[1], t1[2]);  Triangle tri3 = Triangle(t2[0], t2[1], t2[2]);  tri1.drawFill(image, red);  tri2.drawFill(image, white);  tri3.drawFill(image, green);  image.flip_vertically(); // i want to have the origin at the left bottom                           // corner of the image  image.write_tga_file("output_mod.tga");  return 0;},v
void drawObjWire(const char *filename, TGAImage &Image, const TGAColor &Color) {  Model *model = NULL;  model = new Model(filename);  int width = Image.get_width();  int height = Image.get_height();  for (int i = 0; i < model->nfaces(); i++) {    std::vector<int> face = model->face(i);    for (int j = 0; j < 3; j++) {      Vec3f v0 = model->vert(face[j]);      Vec3f v1 = model->vert(face[(j + 1) % 3]);      int x0 = (v0.x + 1.) * width / 2;      int y0 = (v0.y + 1.) * height / 2;      int x1 = (v1.x + 1.) * width / 2;      int y1 = (v1.y + 1.) * height / 2;      Vec2i t0;      Vec2i t1;      t0.x = x0;      t0.y = y0;      t1.x = x1;      t1.y = y1;      line(t0, t1, Image, Color);    }  }  delete model;},v
  riangle tri3 = Triangle(t2[0], t2[1], t2[2]);,V
x,v
